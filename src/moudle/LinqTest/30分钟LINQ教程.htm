<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="referrer" content="origin" />
    <title>30分钟LINQ教程 - liulun - 博客园</title>
<meta property="og:description" content="千万别被这个页面的滚动条吓到！！！ 我相信你一定能在30分钟之内看完它！！！ 在说LINQ之前必须先说说几个重要的C#语言特性 一：与LINQ有关的语言特性 1.隐式类型 （1）源起 在隐式类型出现之" />
    <link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=svlZeZMvc3He7PqOD4T7SOuQn0_kIfLBYiy3idqd35Y1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="/skins/darkgreentrip/bundle-darkgreentrip.css?v=EjExWsdi8Ql8RA7Wdq4_YaeuMVhIAL6d2BSGbilapWY1"/>
<link type="text/css" rel="stylesheet" href="/blog/customcss/32486.css?v=MKBZhfKhzS1yok%2fJHQf93CjwgdE%3d"/>
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/darkgreentrip/bundle-darkgreentrip-mobile.css?v=UDjqx7Witj15lOavDDvYAPs4X-lKVDD-U7PDSLg1cK81"/>
    <link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/liulun/rss"/>
    <link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/liulun/rsd.xml"/>
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/liulun/wlwmanifest.xml"/>
    <script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script>var currentBlogId=32486;var currentBlogApp='liulun',cb_enable_mathjax=false;var isLogined=false;</script>
    <script src="/bundles/blog-common.js?v=OFBZTzkHKauV7mtIFLF9jlqrX-sesK9-mY9KjurLrq01" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>


<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/liulun/"><img id="blogLogo" src="/Skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/liulun/">liulun</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/liulun/">首页</a></li>
<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li></li>
<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/liulun/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/liulun/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 351&nbsp; </span>
<span id="stats_article_count">文章 - 7&nbsp; </span>
<span id="stats-comment_count">评论 - 2921</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
        <div id="post_detail">
<!--done-->
<div id="topics">
	<div class = "post">
		<h1 class = "postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html">30分钟LINQ教程</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p style="text-align: center;"><span style="color: #ff0000; font-size: 16px;"><strong>千万别被这个页面的滚动条吓到！！！</strong></span></p>
<p style="text-align: center;"><span style="color: #ff0000; font-size: 16px;"><strong>我相信你一定能在30分钟之内看完它！！！</strong></span></p>
<p>在说LINQ之前必须先说说几个重要的C#语言特性</p>
<p><span style="font-size: 16px;"><strong>一：与LINQ有关的语言特性</strong></span></p>
<p>　　<strong>1.隐式类型</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　在隐式类型出现之前,</p>
<p>　　　　　　我们在声明一个变量的时候,</p>
<p>　　　　　　总是要为一个变量指定他的类型</p>
<p>　　　　　　甚至在foreach一个集合的时候，</p>
<p>　　　　　　也要为遍历的集合的元素，指定变量的类型</p>
<p>　　　　　　隐式类型的出现，</p>
<p>　　　　　　程序员就不用再做这个工作了。</p>
<p>　　　　（2）使用方法</p>
<p>　　　　&nbsp;　　来看下面的代码：<span style="line-height: 1.5;">　　　　</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　var</span> a = <span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;">int a = 1;</span>
　　　　　　<span style="color: #0000ff;">var</span> b = <span style="color: #800000;">"</span><span style="color: #800000;">123</span><span style="color: #800000;">"</span>;<span style="color: #008000;">//</span><span style="color: #008000;">string b = "123"; </span>
　　　　　　<span style="color: #0000ff;">var</span> myObj = <span style="color: #0000ff;">new</span> MyObj();<span style="color: #008000;">//</span><span style="color: #008000;">MyObj myObj = new MyObj()</span></pre>
</div>
<p>　　　　　　上面的每行代码，与每行代码后面的注释，起到的作用是完全一样的</p>
<p>　　　　　　也就是说，在声明一个变量（并且同时给它赋值）的时候，完全不用指定变量的类型，只要一个var就解决问题了</p>
<p>　　　　（3）你担心这样写会降低性能吗？</p>
<p>　　　　　　我可以负责任的告诉你，这样写不会影响性能！</p>
<p>　　　　　　上面的代码和注释里的代码，编译后产生的IL代码（中间语言代码）是完全一样的</p>
<p>　　　　　　（编译器根据变量的值，推导出变量的类型，才产生的IL代码）　　　　　　</p>
<p>　　　　（4）这个关键字的好处：</p>
<p>　　　　　　你不用在声明一个变量并给这个变量赋值的时候，写两次变量类型</p>
<p>　　　　　　（这一点真的为开发者节省了很多时间）</p>
<p>　　　　　　在foreach一个集合的时候，可以使用var关键字来代替书写循环变量的类型</p>
<p>　　　　 （5）注意事项</p>
<p>　　　　　　你不能用var关键字声明一个变量而不给它赋值</p>
<p>　　　　　　因为编译器无法推导出你这个变量是什么类型的。</p>
<p>　　<strong>2.匿名类型</strong></p>
<p>　　　　(1)源起</p>
<p>　　　　　　创建一个对象，一定要先定义这个对象的类型吗？</p>
<p>　　　　　　不一定的！</p>
<p>　　　　　　来看看这段代码</p>
<p>　　　　（2）使用　</p>
<div class="cnblogs_code">
<pre>         <span style="color: #0000ff;">var</span> obj = <span style="color: #0000ff;">new</span> {Guid.Empty, myTitle = <span style="color: #800000;">"</span><span style="color: #800000;">匿名类型</span><span style="color: #800000;">"</span>, myOtherParam = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[] { <span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span><span style="color: #000000;"> } };
         Console.WriteLine(obj.Empty);</span><span style="color: #008000;">//</span><span style="color: #008000;">另一个对象的属性名字，被原封不动的拷贝到匿名对象中来了。</span>
<span style="color: #000000;">         Console.WriteLine(obj.myTitle);
         Console.ReadKey();</span></pre>
</div>
<p><span style="line-height: 1.5;">　　　　　　</span><span style="line-height: 1.5;">new关键字之后就直接为对象定义了属性，并且为这些属性赋值</span></p>
<p>　　　　　　而且，对象创建出来之后，在创建对象的方法中，还可以畅通无阻的访问对象的属性</p>
<p>　　　　　　当把一个对象的属性拷贝到匿名对象中时，可以不用显示的指定属性的名字，这时原始属性的名字会被&ldquo;拷贝&rdquo;到匿名对象中</p>
<p>　　　　（3）注意　　　　</p>
<p>　　　　　　如果你监视变量obj，你会发现，obj的类型是Anonymous Type类型的</p>
<p>　　　　　　不要试图在创建匿名对象的方法外面去访问对象的属性！</p>
<p>　　　　（4）优点</p>
<p>　　　　　　这个特性在网站开发中，序列化和反序列化JSON对象时很有用</p>
<p>　　<strong>3.自动属性</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　为一个类型定义属性，我们一般都写如下的代码：　　　　</p>
<div class="cnblogs_code">
<pre>    　　　　<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyObj2
    　　　　{
        　　　　</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Guid _id;
        　　　　</span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> _Title;
        　　　　</span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Guid id 
        　　　　{
            　　　　</span><span style="color: #0000ff;">get</span> { <span style="color: #0000ff;">return</span><span style="color: #000000;"> _id; }
            　　　　</span><span style="color: #0000ff;">set</span> { _id =<span style="color: #000000;"> value; } 
        　　　　}
        　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span><span style="color: #000000;"> Title
        　　　　{
            　　　　</span><span style="color: #0000ff;">get</span> { <span style="color: #0000ff;">return</span><span style="color: #000000;"> _Title; }
            　　　　</span><span style="color: #0000ff;">set</span> { _Title =<span style="color: #000000;"> value; }
        　　　　}
    　　　　}</span></pre>
</div>
<p>　　　　　　但很多时候，这些私有变量对我们一点用处也没有，比如对象关系映射中的实体类。</p>
<p>　　　　　　自C#3.0引入了自动实现的属性，</p>
<p>　　　　　　以上代码可以写成如下形式：</p>
<p>　　　　（2）使用</p>
<div class="cnblogs_code">
<pre>    　　　　<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MyObj
    　　　　{
        　　　　</span><span style="color: #0000ff;">public</span> Guid id { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
        　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">string</span> Title { <span style="color: #0000ff;">get</span>; <span style="color: #0000ff;">set</span><span style="color: #000000;">; }
    　　　　}</span></pre>
</div>
<p>　　　　　　这个特性也和var关键字一样，是编译器帮我们做了工作，不会影响性能的</p>
<p>　　<strong>4.初始化器</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　我们创建一个对象并给对象的属性赋值，代码一般写成下面的样子　　　　</p>
<div class="cnblogs_code">
<pre>            <span style="color: #0000ff;">var</span> myObj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> MyObj();
            myObj.id </span>=<span style="color: #000000;"> Guid.NewGuid();
            myObj.Title </span>= <span style="color: #800000;">"</span><span style="color: #800000;">allen</span><span style="color: #800000;">"</span>;</pre>
</div>
<p>　　　　　　自C#3.0引入了对象初始化器，</p>
<p>　　　　　　代码可以写成如下的样子</p>
<p>　　　　（2）使用　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　var</span> myObj1 = <span style="color: #0000ff;">new</span> MyObj() { id = Guid.NewGuid(), Title = <span style="color: #800000;">"</span><span style="color: #800000;">allen</span><span style="color: #800000;">"</span> };</pre>
</div>
<p>　　　　　　如果一个对象是有参数的构造函数</p>
<p>　　　　　　那么代码看起来就像这样</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　var</span> myObj1 = <span style="color: #0000ff;">new</span> MyObj (<span style="color: #800000;">"</span><span style="color: #800000;">allen</span><span style="color: #800000;">"</span>) { id = Guid.NewGuid(), Title = <span style="color: #800000;">"</span><span style="color: #800000;">allen</span><span style="color: #800000;">"</span> };</pre>
</div>
<p>　　　　　　集合初始化器的样例代码如下：　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　var</span> arr = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;() { <span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">6</span> };</pre>
</div>
<p>　　　　（3）优点</p>
<p>　　　　　　我个人认为：这个特性不是那么amazing，</p>
<p>　　　　　　这跟我的编码习惯有关，集合初始化器也就罢了，</p>
<p>　　　　　　真的不习惯用对象初始化器初始化一个对象！</p>
<p>　　<strong>5.委托</strong></p>
<p>　　　　（1）使用</p>
<p>　　　　　　我们先来看一个简单的委托代码　　　　</p>
<div class="cnblogs_code">
<pre>    　　　　<span style="color: #0000ff;">delegate</span> Boolean moreOrlessDelgate(<span style="color: #0000ff;">int</span><span style="color: #000000;"> item);
    　　　　</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Program
    　　　　{
        　　　　</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span><span style="color: #000000;">[] args)
        　　　　{
            　　　　</span><span style="color: #0000ff;">var</span> arr = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;() { <span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">6</span>,<span style="color: #800080;">7</span>,<span style="color: #800080;">8</span><span style="color: #000000;"> };
            　　　　</span><span style="color: #0000ff;">var</span> d1 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> moreOrlessDelgate(More);            
            　　　　Print(arr, d1);
            　　　　Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">OK</span><span style="color: #800000;">"</span><span style="color: #000000;">);

            　　　　</span><span style="color: #0000ff;">var</span> d2 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> moreOrlessDelgate(Less);
            　　　　Print(arr, d2);
            　　　　Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">OK</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            　　　　Console.ReadKey();

        　　　　}
        　　　　</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Print(List&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> arr,moreOrlessDelgate dl)
        　　　　{
            　　　　</span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">var</span> item <span style="color: #0000ff;">in</span><span style="color: #000000;"> arr)
            　　　　{
                　　　　</span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (dl(item))
                　　　　{
                    　　　　Console.WriteLine(item);
                　　　　}
            　　　　}
        　　　　}
        　　　　</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span> More(<span style="color: #0000ff;">int</span><span style="color: #000000;"> item)
        　　　　{
            　　　　</span><span style="color: #0000ff;">if</span> (item &gt; <span style="color: #800080;">3</span><span style="color: #000000;">)
            　　　　{ 
                　　　　</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">; 
            　　　　}
            　　　　</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        　　　　}
        　　　　</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">bool</span> Less(<span style="color: #0000ff;">int</span><span style="color: #000000;"> item)
        　　　　{
            　　　　</span><span style="color: #0000ff;">if</span> (item &lt; <span style="color: #800080;">3</span><span style="color: #000000;">)
            　　　　{
                　　　　</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            　　　　}
            　　　　</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        　　　　}
    　　　　}</span></pre>
</div>
<p>　　　　　　这段代码中</p>
<p>　　　　　　&lt;1&gt;首先定义了一个委托类型</p>
<p>　　　　　　　　delegate Boolean moreOrlessDelgate(int item);</p>
<p>　　　　　　　　你看到了，委托和类是一个级别的，确实是这样：委托是一种类型</p>
<p>　　　　　　　　和class标志的类型不一样，这种类型代表某一类方法。</p>
<p>　　　　　　　　这一句代码的意思是：moreOrlessDelgate这个类型代表返回值为布尔类型，输入参数为整形的方法</p>
<p>　　　　　　&lt;2&gt;有类型就会有类型的实例　　</p>
<pre><span>　　　　　　　　var</span> d1 = <span>new</span><span> moreOrlessDelgate(More);  　　　</span></pre>
<pre><span>　　　　　　　　var</span> d2 = <span>new</span><span> moreOrlessDelgate(Less);</span></pre>
<p>　　　　　　　　这两句就是创建moreOrlessDelgate类型实例的代码，</p>
<p>　　　　　　　　它们的输入参数是两个方法</p>
<p>　　　　　　&lt;3&gt;有了类型的实例，就会有操作实例的代码　　　</p>
<pre><span>　　　　　　　　Print(arr, d1);<br /></span></pre>
<pre><span>　　　　　　　　Print(arr, d2);</span></pre>
<p>　　　　　　　　我们把前面两个实例传递给了Print方法</p>
<p>　　　　　　　　这个方法的第二个参数就是moreOrlessDelgate类型的</p>
<p>　　　　　　　　在Print方法内用如下代码，调用委托类型实例所指向的方法</p>
<p>　　　　　　　　dl(item)</p>
<p>　　<strong>6.泛型</strong></p>
<p>　　　　(1)为什么要有泛型</p>
<p>　　　　　　假设你是一个方法的设计者，</p>
<p>　　　　　　这个方法有一个传入参数，有一个返回值。</p>
<p>　　　　　　但你并不知道这个参数和返回值是什么类型的，</p>
<p>　　　　　　如果没有泛型，你可能把参数和返回值的类型都设定为Object了</p>
<p>　　　　　　那时，你心里肯定在想：反正一切都是对象，一切的基类都是Object</p>
<p>　　　　　　没错！你是对的！</p>
<p>　　　　　　这个方法的消费者，会把他的对象传进来（有可能会做一次装箱操作）</p>
<p>　　　　　　并且得到一个Object的返回值，他再把这个返回值强制类型转化为他需要的类型</p>
<p>　　　　　　除了装箱和类型转化时的性能损耗外，代码工作的很好！</p>
<p>　　　　　　那么这些性能损耗能避免掉吗？</p>
<p>　　　　　　有泛型之后就可以了！</p>
<p>　　　　（2）使用</p>
<p>　　　　　　&lt;1&gt;使用简单的泛型</p>
<p>　　　　　　　　先来看下面的代码：　　　　　　　　</p>
<div class="cnblogs_code">
<pre>            　　<span style="color: #0000ff;">var</span> intList = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;() { <span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">3</span><span style="color: #000000;">};
            　　intList.Add(</span><span style="color: #800080;">4</span><span style="color: #000000;">);
            　　intList.Insert(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">5</span><span style="color: #000000;">);
            　　</span><span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">var</span> item <span style="color: #0000ff;">in</span><span style="color: #000000;"> intList)
            　　{
                　　Console.WriteLine(item);
            　　}
            　　Console.ReadKey();</span></pre>
</div>
<p>　　　　　　　　在上面这段代码中我们声明了一个存储int类型的List容器</p>
<p>　　　　　　　　并循环打印出了容器里的值</p>
<p>　　　　　　　　注意：如果这里使用Hashtable、Queue或者Stack等非泛型的容器</p>
<p>　　　　　　　　就会导致装箱操作，损耗性能。因为这些容器只能存储Object类型的数据</p>
<p>　　　　　　&lt;2&gt;泛型类型</p>
<p>　　　　　　　　List&lt;T&gt;、Dictionary&lt;TKey, TValue&gt;等泛型类型都是.net类库定义好并提供给我们使用的</p>
<p>　　　　　　　　但在实际开发中，我们也经常需要定义自己的泛型类型</p>
<p>　　　　　　　　来看下面的代码：　　　　　　　　</p>
<div class="cnblogs_code">
<pre>    　　　　　　<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> SomethingFactory&lt;T&gt;<span style="color: #000000;">
    　　　　　　{
        　　　　　　</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> T InitInstance(T inObj)
        　　　　　　{
            　　　　　　</span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">false</span>)<span style="color: #008000;">//</span><span style="color: #008000;">你的判断条件</span>
<span style="color: #000000;">            　　　　　　{
                　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">do what you want...</span>
                　　　　　　<span style="color: #0000ff;">return</span><span style="color: #000000;"> inObj;
            　　　　　　}
            　　　　　　</span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">default</span><span style="color: #000000;">(T);
        　　　　　　}
    　　　　　　}</span></pre>
</div>
<p>　　　　　　　　这段代码的消费者如下：　　　　　　　　</p>
<div class="cnblogs_code">
<pre>            　　<span style="color: #0000ff;">var</span> a1 = SomethingFactory&lt;<span style="color: #0000ff;">int</span>&gt;.InitInstance(<span style="color: #800080;">12</span><span style="color: #000000;">);
            　　Console.WriteLine(a1);
            　　Console.ReadKey();</span></pre>
</div>
<p>　　　　　　　　输出的结果为0</p>
<p>　　　　　　　　这就是一个自定义的静态泛型类型，</p>
<p>　　　　　　　　此类型中的静态方法InitInstance对传入的参数做了一个判断</p>
<p>　　　　　　　　如果条件成立，则对传入参数进行操作之后并把它返回</p>
<p>　　　　　　　　如果条件不成立，则返回一个空值</p>
<p>　　　　　　　　注意：</p>
<p>　　　　　　　　　　[1]</p>
<p>　　　　　　　　　　　　传入参数必须为指定的类型，</p>
<p>　　　　　　　　　　　　因为我们在使用这个泛型类型的时候，已经规定好它能接收什么类型的参数</p>
<p>　　　　　　　　　　　　但在设计这个泛型的时候，我们并不知道使用者将传递什么类型的参数进来</p>
<p>　　　　　　　　　　[2]</p>
<p>　　　　　　　　　　　　如果你想返回T类型的空值，那么请用default(T)这种形式</p>
<p>　　　　　　　　　　　　因为你不知道T是值类型还是引用类型，所以别擅自用null</p>
<p>　　　　　　&lt;3&gt;泛型约束</p>
<p>　　　　　　　　很多时候我们不希望使用者太过自由</p>
<p>　　　　　　　　我们希望他们在使用我们设计的泛型类型时</p>
<p>　　　　　　　　不要很随意的传入任何类型</p>
<p>　　　　　　　　对于泛型类型的设计者来说，要求使用者传入指定的类型是很有必要的</p>
<p>　　　　　　　　因为我们只有知道他传入了什么东西，才方便对这个东西做操作</p>
<p>　　　　　　　　让我们来给上面设计的泛型类型加一个泛型约束</p>
<p>　　　　　　　　代码如下：　　　　　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　　　　　public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> SomethingFactory&lt;T&gt; <span style="color: #0000ff;">where</span> T:MyObj</pre>
</div>
<p>　　　　　　　　这样在使用SomethingFactory的时候就只能传入MyObj类型或MyObj的派生类型啦</p>
<p>　　　　　　　　注意：</p>
<p>　　　　　　　　　　还可以写成这样</p>
<p>　　　　　　　　　　where T:MyObj,new()</p>
<p>　　　　　　　　　　来约束传入的类型必须有一个构造函数。　　　　　　　　</p>
<p>　　　　（3）泛型的好处</p>
<p>　　　　　　&lt;1&gt;算法的重用</p>
<p>　　　　　　　　想想看：list类型的排序算法，对所有类型的list集合都是有用的</p>
<p>　　　　　　&lt;2&gt;类型安全</p>
<p>　　　　　　&lt;3&gt;提升性能</p>
<p>　　　　　　　　没有类型转化了，一方面保证类型安全，另一方面保证性能提升</p>
<p>　　　　　　&lt;4&gt;可读性更好</p>
<p>　　　　　　　　这一点就不解释了&nbsp;</p>
<p>　　<strong>7.泛型委托</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　委托需要定义delgate类型</p>
<p>　　　　　　使用起来颇多不便</p>
<p>　　　　　　而且委托本就代表某一类方法</p>
<p>　　　　　　开发人员经常使用的委托基本可以归为三类，</p>
<p>　　　　　　哪三类呢？</p>
<p>　　　　　　请看下面：</p>
<p>　　　　（2）使用</p>
<p>　　　　　　&lt;1&gt;Predicate泛型委托</p>
<p>　　　　　　　　把上面例子中d1和d2赋值的两行代码改为如下：　　　　</p>
<div class="cnblogs_code">
<pre>            　　<span style="color: #008000;">//</span><span style="color: #008000;">var d1 = new moreOrlessDelgate(More);</span>
            　　<span style="color: #0000ff;">var</span> d1 = <span style="color: #0000ff;">new</span> Predicate&lt;<span style="color: #0000ff;">int</span>&gt;(More);</pre>
</div>
<div class="cnblogs_code">
<pre>            　　<span style="color: #008000;">//</span><span style="color: #008000;">var d2 = new moreOrlessDelgate(Less);</span>
            　　<span style="color: #0000ff;">var</span> d2 = <span style="color: #0000ff;">new</span> Predicate&lt;<span style="color: #0000ff;">int</span>&gt;(Less);</pre>
</div>
<p>　　　　　　　　把Print方法的方法签名改为如下：　　　　</p>
<div class="cnblogs_code">
<pre>        　　　　<span style="color: #008000;">//</span><span style="color: #008000;">static void Print(List&lt;int&gt; arr, moreOrlessDelgate&lt;int&gt; dl)</span>
        　　　　<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Print(List&lt;<span style="color: #0000ff;">int</span>&gt; arr, Predicate&lt;<span style="color: #0000ff;">int</span>&gt; dl)</pre>
</div>
<p>　　　　　　　　然后再运行方法，控制台输出的结果和原来的结果是一模一样的。</p>
<p>　　　　　　　　那么Predicate到底是什么呢？</p>
<p>　　　　　　　　来看看他的定义：　　　　</p>
<div class="cnblogs_code">
<pre>    　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 摘要:
    　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">     表示定义一组条件并确定指定对象是否符合这些条件的方法。
    　　　　　　</span><span style="color: #008000;">//</span>
    　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 参数:
    　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">   obj:
    　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">     要按照由此委托表示的方法中定义的条件进行比较的对象。
    　　　　　　</span><span style="color: #008000;">//</span>
    　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 类型参数:
    　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">   T:
    　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">     要比较的对象的类型。
    　　　　　　</span><span style="color: #008000;">//</span>
    　　　　　　<span style="color: #008000;">//</span><span style="color: #008000;"> 返回结果:
    　　　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">     如果 obj 符合由此委托表示的方法中定义的条件，则为 true；否则为 false。</span>
    　　　　　　<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> <span style="color: #0000ff;">bool</span> Predicate&lt;<span style="color: #0000ff;">in</span> T&gt;(T obj);</pre>
</div>
<p>　　　　　　　　看到这个定义，我们大致明白了。</p>
<p>　　　　　　　　.net为我们定义了一个委托，</p>
<p>　　　　　　　　这个委托表示的方法需要传入一个T类型的参数，并且需要返回一个bool类型的返回值</p>
<p>　　　　　　　　有了它，我们就不用再定义moreOrlessDelgate委托了，</p>
<p>　　　　　　　　而且，我们定义的moreOrlessDelgate只能搞int类型的参数，</p>
<p>　　　　　　　　Predicate却不一样，它可以搞任意类型的参数</p>
<p>　　　　　　　　但它规定的还是太死了，它必须有一个返回值，而且必须是布尔类型的，同时，它必须有一个输入参数</p>
<p>　　　　　　　　除了Predicate泛型委托，.net还为我们定义了Action和Func两个泛型委托</p>
<p>　　　　　　&lt;2&gt;Action泛型委托</p>
<p>　　　　　　　　Action泛型委托限制的就不那么死了，</p>
<p>　　　　　　　　他代表了一类方法：</p>
<p>　　　　　　　　可以有0个到16个输入参数，</p>
<p>　　　　　　　　输入参数的类型是不确定的，</p>
<p>　　　　　　　　但不能有返回值，</p>
<p>　　　　　　　　来看个例子：　　　　　　</p>
<div class="cnblogs_code">
<pre>            　　<span style="color: #0000ff;">var</span> d3 = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Action(noParamNoReturnAction);
            　　</span><span style="color: #0000ff;">var</span> d4 = <span style="color: #0000ff;">new</span> Action&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;(twoParamNoReturnAction);</pre>
</div>
<p>&nbsp;　　　　　　　　注意：尖括号中int和string为方法的输入参数</p>
<div class="cnblogs_code">
<pre>        　　　　<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> noParamNoReturnAction()
        　　　　{
            　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">do what you want</span>
<span style="color: #000000;">        　　　　}
        　　　　</span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> twoParamNoReturnAction(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">string</span><span style="color: #000000;"> b)
        　　　　{
            　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">do what you want</span>
        　　　　}</pre>
</div>
<p>&nbsp;<span style="line-height: 1.5;">　　　　　　&lt;3&gt;Func泛型委托</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　为了弥补Action泛型委托，不能返回值的不足</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　.net提供了Func泛型委托，</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　相同的是它也是最多0到16个输入参数，参数类型由使用者确定</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　不同的是它规定要有一个返回值，返回值的类型也由使用者确定</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　如下示例：</span><span style="line-height: 1.5;">　　　　　　</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　　　　　var</span> d5 = <span style="color: #0000ff;">new</span> Func&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;(oneParamOneReturnFunc);</pre>
</div>
<p>　　　　　　　　注意：string类型（最后一个泛型类型）是方法的返回值类型</p>
<div class="cnblogs_code">
<pre>        　　　　<span style="color: #0000ff;">static</span> <span style="color: #0000ff;">string</span> oneParamOneReturnFunc(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a)
        　　　　{
            　　　　</span><span style="color: #008000;">//</span><span style="color: #008000;">do what you want</span>
            　　　　<span style="color: #0000ff;">return</span> <span style="color: #0000ff;">string</span><span style="color: #000000;">.Empty;
        　　　　}</span></pre>
</div>
<p>　　<strong>8.匿名方法</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　在上面的例子中</p>
<p>　　　　　　为了得到序列中较大的值</p>
<p>　　　　　　我们定义了一个More方法　　　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　var</span> d1 = <span style="color: #0000ff;">new</span> Predicate&lt;<span style="color: #0000ff;">int</span>&gt;(More);</pre>
</div>
<p>　　　　　　然而这个方法，没有太多逻辑（实际编程过程中，如果逻辑较多，确实应该独立一个方法出来）</p>
<p>　　　　　　那么能不能把More方法中的逻辑，直接写出来呢？</p>
<p>　　　　　　C#2.0之后就可以了，</p>
<p>　　　　　　请看下面的代码：</p>
<p>　　　　（2）使用　　　　　　</p>
<div class="cnblogs_code">
<pre>            <span style="color: #0000ff;">var</span> arr = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;() { <span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">8</span><span style="color: #000000;"> };
            </span><span style="color: #008000;">//</span><span style="color: #008000;">var d1 = new moreOrlessDelgate(More);
            </span><span style="color: #008000;">//</span><span style="color: #008000;">var d1 = new Predicate&lt;int&gt;(More);</span>
            <span style="color: #0000ff;">var</span> d1 = <span style="color: #0000ff;">new</span> Predicate&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #0000ff;">delegate</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;"> item)
            {<br /></span></pre>
<p> 　　　　　　　　　　//可以访问当前上下文中的变量<br />                　　　　　　　　　　Console.WriteLine(arr.Count);</p>
<p><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="color: #0000ff;">if</span> (item &gt; <span style="color: #800080;">3</span><span>)</span></p>
<pre><span style="color: #000000;">                {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            });
            Print(arr, d1);
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">OK</span><span style="color: #800000;">"</span>);</pre>
</div>
<p>　　　　　　我们传递了一个代码块给Predicate的构造函数</p>
<p>　　　　　　其实这个代码块就是More函数的逻辑</p>
<p>　　　　（3）好处</p>
<p>　　　　　　&lt;1&gt;代码可读性更好</p>
<p>　　　　　　&lt;2&gt;可以访问当前上下文中的变量</p>
<p>　　　　　　　　这个用处非常大，</p>
<p>　　　　　　　　如果我们仍旧用原来的More函数</p>
<p>　　　　　　　　想要访问arr变量，势必要把arr写成类级别的私有变量了</p>
<p>　　　　　　　　用匿名函数的话，就不用这么做了。</p>
<p>　　<strong>9.Lambda表达式</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　.net的设计者发现在使用匿名方法时，</p>
<p>　　　　　　仍旧有一些多余的字母或单词的编码工作</p>
<p>　　　　　　比如delegate关键字</p>
<p>　　　　　　于是进一步简化了匿名方法的写法</p>
<p>　　　　（2）使用　　　　　　</p>
<div class="cnblogs_code">
<pre>            List&lt;<span style="color: #0000ff;">int</span>&gt; arr = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;() { <span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">7</span><span style="color: #000000;"> };
            arr.ForEach(</span><span style="color: #0000ff;">new</span> Action&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #0000ff;">delegate</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a) { Console.WriteLine(a); }));
            arr.ForEach(</span><span style="color: #0000ff;">new</span> Action&lt;<span style="color: #0000ff;">int</span>&gt;(a =&gt; Console.WriteLine(a)));</pre>
</div>
<p>&nbsp;　　　　　　匿名方法的代码如下：</p>
<p>　　　　　　delegate(int a) { Console.WriteLine(a); }</p>
<p>　　　　　　使用lambda表达式的代码如下：</p>
<p>　　　　　　a =&gt; Console.WriteLine(a)</p>
<p>　　　　　　这里解释一下这个lambda表达式</p>
<p>　　　　　　&lt;1&gt;</p>
<p>　　　　　　　　a是输入参数，编译器可以自动推断出它是什么类型的，</p>
<p>　　　　　　　　如果没有输入参数，可以写成这样：</p>
<p>　　　　　　　　() =&gt; Console.WriteLine("ddd")</p>
<p>　　　　　　&lt;2&gt;</p>
<p>　　　　　　　　=&gt;是lambda操作符</p>
<p>　　　　　　&lt;3&gt;</p>
<p>　　　　　　　　Console.WriteLine(a)是要执行的语句。</p>
<p>　　　　　　　　如果是多条语句的话，可以用{}包起来。</p>
<p>　　　　　　　　如果需要返回值的话，可以直接写return语句</p>
<p>　　<strong>10.扩展方法</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　如果想给一个类型增加行为，一定要通过继承的方式实现吗？</p>
<p>　　　　　　不一定的！</p>
<p>　　　　（2）使用</p>
<p>　　　　　　来看看这段代码：　　　　</p>
<div class="cnblogs_code">
<pre>        　　<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> PrintString(<span style="color: #0000ff;">this</span><span style="color: #000000;"> String val)
        　　{
            　　Console.WriteLine(val);
        　　}</span></pre>
</div>
<p>　　　　　　消费这段代码的代码如下：　　　　</p>
<div class="cnblogs_code">
<pre>            <span style="color: #0000ff;">var</span> a = <span style="color: #800000;">"</span><span style="color: #800000;">aaa</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            a.PrintString();
            Console.ReadKey();</span></pre>
</div>
<p>　　　　　　我想你看到扩展方法的威力了。</p>
<p>　　　　　　本来string类型没有PrintString方法</p>
<p>　　　　　　但通过我们上面的代码，就给string类型"扩展"了一个PrintString方法</p>
<p>　　　　　　（1）先决条件</p>
<p>　　　　　　　　&lt;1&gt;扩展方法必须在一个非嵌套、非泛型的静态类中定义</p>
<p>　　　　　　　　&lt;2&gt;扩展方法必须是一个静态方法</p>
<p>　　　　　　　　&lt;3&gt;扩展方法至少要有一个参数</p>
<p>　　　　　　　　&lt;4&gt;第一个参数必须附加this关键字作为前缀</p>
<p>　　　　　　　　&lt;5&gt;第一个参数不能有其他修饰符（比如ref或者out）</p>
<p>　　　　　　　　&lt;6&gt;第一个参数不能是指针类型</p>
<p>　　　　　　（2）注意事项</p>
<p>　　　　　　　　&lt;1&gt;跟前面提到的几个特性一样，扩展方法只会增加编译器的工作，不会影响性能（用继承的方式为一个类型增加特性反而会影响性能）</p>
<p>　　　　　　　　&lt;2&gt;如果原来的类中有一个方法，跟你的扩展方法一样（至少用起来是一样），那么你的扩展方法奖不会被调用，编译器也不会提示你</p>
<p>　　　　　　　　&lt;3&gt;扩展方法太强大了，会影响架构、模式、可读性等等等等....</p>
<p>　　<strong>11.迭代器</strong></p>
<p>　　&middot;　　（1）使用</p>
<p>　　　　　　我们每次针对集合类型编写foreach代码块，都是在使用迭代器</p>
<p>　　　　　　这些集合类型都实现了IEnumerable接口</p>
<p>　　　　　　都有一个GetEnumerator方法</p>
<p>　　　　　　但对于数组类型就不是这样</p>
<p>　　　　　　编译器把针对数组类型的foreach代码块</p>
<p>　　　　　　替换成了for代码块。</p>
<p>　　　　　　来看看List的类型签名：　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　public</span> <span style="color: #0000ff;">class</span> List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable</pre>
</div>
<p>　　　　　　IEnumerable接口，只定义了一个方法就是：　　　　</p>
<div class="cnblogs_code">
<pre>　　　　　　IEnumerator&lt;T&gt; GetEnumerator();</pre>
</div>
<p>　　　　（2）迭代器的优点：</p>
<p>　　　　　　假设我们需要遍历一个庞大的集合</p>
<p>　　　　　　只要集合中的某一个元素满足条件</p>
<p>　　　　　　就完成了任务</p>
<p>　　　　　　你认为需要把这个庞大的集合全部加载到内存中来吗？</p>
<p>　　　　　　当然不用（C#3.0之后就不用了）！</p>
<p>　　　　　　来看看这段代码：　　　　　　</p>
<div class="cnblogs_code">
<pre>        <span style="color: #0000ff;">static</span> IEnumerable&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> GetIterator()
        {
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">迭代器返回了1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">迭代器返回了2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span><span style="color: #000000;">;
            Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">迭代器返回了3</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">3</span><span style="color: #000000;">;
        }</span></pre>
</div>
<p>　　　　　　消费这个函数的代码如下：　　　　　　</p>
<div class="cnblogs_code">
<pre>            <span style="color: #0000ff;">foreach</span> (<span style="color: #0000ff;">var</span> i <span style="color: #0000ff;">in</span><span style="color: #000000;"> GetIterator())
            {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">2</span><span style="color: #000000;">)
                {
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                Console.WriteLine(i);
            }
            Console.ReadKey();</span></pre>
</div>
<p>　　　　　　输出结果为：　　　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">　　　　　　迭代器返回了1
　　　　　　</span><span style="color: #800080;">1</span><span style="color: #000000;">
　　　　　　迭代器返回了2</span></pre>
</div>
<p>　　　　　　大家可以看到：</p>
<p>　　　　　　当迭代器返回2之后，foreach就退出了</p>
<p>　　　　　　并没有输出&ldquo;迭代器返回了3&rdquo;</p>
<p>　　　　　　也就是说下面的工作没有做。</p>
<p>　　　　（3）yield 关键字</p>
<p>　　　　　　MSDN中的解释如下：</p>
<p>　　　　　　在迭代器块中用于向枚举数对象提供值或发出迭代结束信号。</p>
<p>　　　　　　也就是说，我们可以在生成迭代器的时候，来确定什么时候终结迭代逻辑</p>
<p>　　　　　　上面的代码可以改成如下形式：　　　　　　</p>
<div class="cnblogs_code">
<pre>        　　<span style="color: #0000ff;">static</span> IEnumerable&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> GetIterator()
        　　{
            　　Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">迭代器返回了1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            　　</span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            　　Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">迭代器返回了2</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            　　</span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            　　Console.WriteLine(</span><span style="color: #800000;">"</span><span style="color: #800000;">迭代器返回了3</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            　　</span><span style="color: #0000ff;">yield</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">3</span><span style="color: #000000;">;
        　　}</span></pre>
</div>
<p>&nbsp;　　　　(4)注意事项</p>
<p>　　　　　　&lt;1&gt;做foreach循环时多考虑线程安全性　　　　　　</p>
<p>　　　　　　　　在foreach时不要试图对被遍历的集合进行remove和add等操作</p>
<p>　　　　　　　　任何集合，即使被标记为线程安全的，在foreach的时候，增加项和移除项的操作都会导致异常</p>
<p>　　　　　　　　（我在这里犯过错）</p>
<p>　　　　　　&lt;2&gt;IEnumerable接口是LINQ特性的核心接口</p>
<p>　　　　　　　　只有实现了IEnumerable接口的集合</p>
<p>　　　　　　　　才能执行相关的LINQ操作，比如select,where等</p>
<p>　　　　　　　　这些操作，我们接下来会讲到。</p>
<p><strong><span style="font-size: 16px;">二：LINQ</span></strong></p>
<p>　　<strong>1.查询操作符</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　.net的设计者在类库中定义了一系列的扩展方法</p>
<p>　　　　　　来方便用户操作集合对象</p>
<p>　　　　　　这些扩展方法构成了LINQ的查询操作符</p>
<p>　　　　（2）使用</p>
<p>　　　　　　这一系列的扩展方法，比如：</p>
<p>　　　　　　Where，Max，Select，Sum，Any，Average，All，Concat等</p>
<p>　　　　　　都是针对IEnumerable的对象进行扩展的</p>
<p>　　　　　　也就是说，只要实现了IEnumerable接口，就可以使用这些扩展方法</p>
<p>　　　　　　来看看这段代码：　　　　　　</p>
<div class="cnblogs_code">
<pre>            List&lt;<span style="color: #0000ff;">int</span>&gt; arr = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">int</span>&gt;() { <span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">7</span><span style="color: #000000;"> };
            </span><span style="color: #0000ff;">var</span> result = arr.Where(a =&gt; { <span style="color: #0000ff;">return</span> a &gt; <span style="color: #800080;">3</span><span style="color: #000000;">; }).Sum();
            Console.WriteLine(result);
            Console.ReadKey();</span></pre>
</div>
<p>　　　　　　这段代码中，用到了两个扩展方法。</p>
<p>　　　　　　&lt;1&gt;</p>
<p>　　　　　　　　Where扩展方法，需要传入一个Func&lt;int,bool&gt;类型的泛型委托</p>
<p>　　　　　　　　这个泛型委托，需要一个int类型的输入参数和一个布尔类型的返回值</p>
<p>　　　　　　　　我们直接把a =&gt; { return a &gt; 3; }这个lambda表达式传递给了Where方法</p>
<p>　　　　　　　　a就是int类型的输入参数，返回a是否大于3的结果。</p>
<p>　　　　　　&lt;2&gt;</p>
<p>　　　　　　　　Sum扩展方法计算了Where扩展方法返回的集合的和。</p>
<p>　　　　（3）好处</p>
<p>　　　　　　上面的代码中</p>
<p>　　　　　　arr.Where(a =&gt; { return a &gt; 3; }).Sum();</p>
<p>　　　　　　这一句完全可以写成如下代码：</p>
<p>　　　　　　(from v in arr where v &gt; 3 select v).Sum();</p>
<p>　　　　　　而且两句代码的执行细节是完全一样的</p>
<p>　　　　　　大家可以看到,第二句代码更符合语义，更容易读懂</p>
<p>　　　　　　第二句代码中的where，就是我们要说的查询操作符。</p>
<p>　　　　（4）标准查询操作符说明</p>
<p>　　　　　　&lt;1&gt;过滤</p>
<p>　　　　　　　　Where</p>
<p>　　　　　　　　用法：arr.Where(a =&gt; { return a &gt; 3; })</p>
<p>　　　　　　　　说明：找到集合中满足指定条件的元素</p>
<p>　　　　　　　　OfType</p>
<p>　　　　　　　　用法：arr.OfType&lt;int&gt;()</p>
<p>　　　　　　　　说明：根据指定类型，筛选集合中的元素</p>
<p>　　　　　　&lt;2&gt;投影</p>
<p>　　　　　　　　Select</p>
<p>　　　　　　　　用法：arr.Select&lt;int, string&gt;(a =&gt; a.ToString());</p>
<p>　　　　　　　　说明：将集合中的每个元素投影的新集合中。上例中：新集合是一个IEnumerable&lt;String&gt;的集合</p>
<p>　　　　　　　　SelectMany</p>
<p>　　　　　　　　用法：arr.SelectMany&lt;int, string&gt;(a =&gt; { return new List&lt;string&gt;() { "a", a.ToString() }; });</p>
<p>　　　　　　　　说明：将序列的每个元素投影到一个序列中，最终把所有的序列合并</p>
<p>　　　　　　&lt;3&gt;还有很多查询操作符，请翻MSDN，以后有时间我将另起一篇文章把这些操作符写全。　　　　　　</p>
<p>　　<strong>2.查询表达式</strong></p>
<p>　　　　（1）源起</p>
<p>　　　　　　上面我们已经提到，使用查询操作符表示的扩展方法来操作集合；</p>
<p>　　　　　　虽然已经很方便了，但在可读性和代码的语义来考虑，仍有不足；</p>
<p>　　　　　　于是就产生了查询表达式的写法。</p>
<p>　　　　　　虽然这很像SQL语句，但他们却有着本质的不同。</p>
<p>　　　　（2）用法</p>
<p>　　　　　　from v in arr where v &gt; 3 select v</p>
<p>　　　　　　这就是一个非常简单的查询表达式</p>
<p>　　　　（3）说明：</p>
<p>　　　　　　先看一段伪代码：　　　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　from</span> [type] id <span style="color: #0000ff;">in</span><span style="color: #000000;"> source
　　　　　　[join [type] id </span><span style="color: #0000ff;">in</span><span style="color: #000000;"> source on expr equals expr [into subGroup]]
　　　　　　[</span><span style="color: #0000ff;">from</span> [type] id <span style="color: #0000ff;">in</span> source | let id = expr | <span style="color: #0000ff;">where</span><span style="color: #000000;"> condition]
　　　　　　[</span><span style="color: #0000ff;">orderby</span><span style="color: #000000;"> ordering,ordering,ordering...]
　　　　　　</span><span style="color: #0000ff;">select</span> expr |<span style="color: #000000;"> group expr by key
　　　　　　[into id query]</span></pre>
</div>
<p>　　　　　　&lt;1&gt;第一行的解释：</p>
<p>　　　　　　　　type是可选的，</p>
<p>　　　　　　　　<span style="line-height: 1.5;">id是集合中的一项，</span></p>
<p>　　　　　　　　source是一个集合，</p>
<p>　　　　　　　　如果集合中的类型与type指定的类型不同则导致强制类型转化</p>
<p>　　　　　　&lt;2&gt;第二行的解释：　　　　　　　　</p>
<p>　　　　　　　　一个查询表达式中可以有0个或多个join子句，</p>
<p>　　　　　　　　这里的source可以是一个全新的集合，可以不等于第一句中的source</p>
<p>　　　　　　　　expr可以是一个表达式</p>
<p>　　　　　　　　[into subGroup] subGroup是一个中间变量，</p>
<p>　　　　　　　　它继承自IGrouping，代表一个分组，也就是说&ldquo;一对多&rdquo;里的&ldquo;多&rdquo;</p>
<p>　　　　　　　　可以通过这个变量得到这一组包含的对象个数，以及这一组对象的键</p>
<p>　　　　　　　　比如：　　　　　　　　</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">　　　　　　　　from</span> c <span style="color: #0000ff;">in</span><span style="color: #000000;"> db.Customers
        　　　　join o </span><span style="color: #0000ff;">in</span><span style="color: #000000;"> db.Orders on c.CustomerID
        　　　　equals o.CustomerID into orders
        　　　　</span><span style="color: #0000ff;">select</span> <span style="color: #0000ff;">new</span><span style="color: #000000;">
        　　　　{
            　　　　c.ContactName,
            　　　　OrderCount </span>=<span style="color: #000000;"> orders.Count()
        　　　　};</span></pre>
</div>
<p>　　　　　　&lt;3&gt;第三行的解释：　　　　　</p>
<p>　　　　　　　　<span style="line-height: 1.5;">一个查询表达式中可以有1个或多个from子句</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　</span>一个查询表达式中可以有0个或多个let子句，let子句可以创建一个临时变量</p>
<p>　　　　　　　　比如：　　　　　　　　</p>
<div class="cnblogs_code">
<pre>        　　　　<span style="color: #0000ff;">from</span> u <span style="color: #0000ff;">in</span><span style="color: #000000;"> users
         　　　　let number </span>= Int32.Parse(u.Username.Substring(u.Username.Length - <span style="color: #800080;">1</span><span style="color: #000000;">))
         　　　　</span><span style="color: #0000ff;">where</span> u.ID &lt; <span style="color: #800080;">9</span> &amp;&amp; number % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>
         　　　　<span style="color: #0000ff;">select</span> u</pre>
</div>
<p>　　　　　　　　一个查询表达式中可以有0个或多个where子句，where子句可以指定查询条件</p>
<p>　　　　　　&lt;4&gt;第四行的解释：</p>
<p>　　　　　　　　<span style="line-height: 1.5;">一个查询表达式可以有0个或多个排序方式</span></p>
<p>　　　　　　　　每个排序方式以逗号分割</p>
<p>　　　　　　&lt;5&gt;第五行的解释：</p>
<p>　　　　　　　　<span style="line-height: 1.5;">一个查询表达式必须以select或者group by结束</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　</span>select后跟要检索的内容</p>
<p>　　　　　　　　group by 是对检索的内容进行分组</p>
<p>　　　　　　　　比如：　　　　　　　　</p>
<div class="cnblogs_code">
<pre>        　　　　<span style="color: #0000ff;">from</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> db.Products  
        　　　　group p by p.CategoryID into g  
        　　　　</span><span style="color: #0000ff;">select</span> <span style="color: #0000ff;">new</span> {  g.Key, NumProducts = g.Count()}; </pre>
</div>
<p>　　　　　　&lt;6&gt;第六行的解释：</p>
<p>　　　　　　　　<span style="line-height: 1.5;">最后一个into子句起到的作用是</span></p>
<p><span style="line-height: 1.5;">　　　　　　　　将前面语句的结果作为后面语句操作的数据源</span></p>
<p>　　　　　　　　比如：　　　　　　　　</p>
<div class="cnblogs_code">
<pre>        　　　　<span style="color: #0000ff;">from</span> p <span style="color: #0000ff;">in</span><span style="color: #000000;"> db.Employees
         　　　　</span><span style="color: #0000ff;">select</span> <span style="color: #0000ff;">new</span><span style="color: #000000;">
         　　　　{
             　　　　LastName </span>=<span style="color: #000000;"> p.LastName,
             　　　　TitleOfCourtesy </span>=<span style="color: #000000;"> p.TitleOfCourtesy
         　　　　} into EmployeesList
         　　　　</span><span style="color: #0000ff;">orderby</span><span style="color: #000000;"> EmployeesList.TitleOfCourtesy ascending
         　　　　</span><span style="color: #0000ff;">select</span> EmployeesList;</pre>
</div>
<p><span style="font-size: 16px;"><strong>三：参考资料</strong></span></p>
<p>　　《LINQ实战》</p>
<p>　　《深入理解C#》第二版</p>
<p>　　《CLR VIA C#》第三版</p>
<p>　　《C# 高级编程》第四版</p>
<p>　　还有很多网络上的文章，就不一一例举了</p>
<p><strong><span style="font-size: 16px;">四：修改记录</span></strong></p>
<p>　　1.2013-02-12夜</p>
<p>　　　　（1）完成了第一部分的大多数内容</p>
<p>　　　　（2）修改了文章的排版</p>
<p>　　　　（3）通读了第一部分，修改了一些读起来不通顺的语句，修改了错别字</p>
<p>　　2.2013-02-26夜</p>
<p>　　　　（1）完成了第二部分的内容</p>
<p>　　　　（2）删掉了表达式树的内容【文章篇幅实在太长了】</p>
<p>　　　　（3）完善了第一部分的内容</p>
<p>　　2.2013-02-27晨</p>
<p>　　　　（1）修改了一些错别字</p>
<p>　　3.2017-03-02午后</p>
<p>　　　　（1）修改了几个错别字，几个标点符号</p>
<p>&nbsp;</p>
<p style="text-align: center;"><strong><span style="font-size: 16px; color: #ff0000;">好吧！我承认我骗你了！</span></strong></p>
<p style="text-align: center;"><strong><span style="font-size: 16px; color: #ff0000;"><span style="text-decoration: underline;">一般人</span>不可能在30分钟内看完这篇文章！</span></strong></p>
<p style="text-align: center;"><strong><span style="font-size: 16px; color: #ff0000;">I'm sorry.Forgive me!</span></strong></p>
<p>&nbsp;</p>
<p>　　　　</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>


		</div>
		<div class = "postDesc">posted @ <span id="post-date">2013-02-26 19:10</span> <a href='https://www.cnblogs.com/liulun/'>liulun</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href ="https://i.cnblogs.com/EditPosts.aspx?postid=2909985" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(2909985);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=32486,cb_entryId=2909985,cb_blogApp=currentBlogApp,cb_blogUserGuid='e08a3d0b-63cf-dd11-9e4d-001cf0cd104b',cb_entryCreatedDate='2013/2/26 19:10:00';loadViewCount(cb_entryId);var cb_postType=1;var isMarkdown=false;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id='comment_form' class='commentform'>
<a name='commentform'></a>
<div id='divCommentShow'></div>
<div id='comment_nav'><span id='span_refresh_tips'></span><a href='javascript:void(0);' onclick='return RefreshCommentList();' id='lnk_RefreshComments' runat='server' clientidmode='Static'>刷新评论</a><a href='#' onclick='return RefreshPage();'>刷新页面</a><a href='#top'>返回顶部</a></div>
<div id='comment_form_container'></div>
<div class='ad_text_commentbox' id='ad_text_under_commentbox'></div>
<div id='ad_t2'></div>
<div id='opt_under_post'></div>
<script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>
<script>
  googletag.cmd.push(function() {
        googletag.defineSlot('/1090369/C1', [300, 250], 'div-gpt-ad-1546353474406-0').addService(googletag.pubads());
        googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
  });
</script>
<div id='cnblogs_c1' class='c_ad_block'>
    <div id='div-gpt-ad-1546353474406-0' style='height:250px; width:300px;'></div>
</div>
<div id='under_post_news'></div>
<div id='cnblogs_c2' class='c_ad_block'>
    <div id='div-gpt-ad-1539008685004-0' style='height:60px; width:468px;'></div>
</div>
<div id='under_post_kb'></div>
<div id='HistoryToday' class='c_ad_block'></div>
<script type='text/javascript'>
 if(enablePostBottom()) {
    codeHighlight();
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverT2();
    deliverC1();
    deliverC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);  
}
</script>
</div>

    
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright &copy;2019 liulun
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->

</body>
</html>
